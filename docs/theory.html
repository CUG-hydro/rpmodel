<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Theory</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<div class="container-fluid main-container">

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">rpmodel</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="usage.html">Usage</a>
</li>
<li>
  <a href="theory.html">Theory</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Theory</h1>

</div>


<p>The P-model predicts an optimal ratio of <span class="math inline">\(c_i : c_a\)</span>, termed as <span class="math inline">\(\chi\)</span>, that balances the costs associated with maintaining the transpiration (<span class="math inline">\(E\)</span>) stream and the carboxylation capacity <span class="math inline">\(V_{\text{cmax}}\)</span>. It can therefore be used to simulate the acclimation of the photosynthetic machinery to its environment - a mechanism that happens at a time scale of several days to months. At its core, it provides a solution for the optimality criterium <span class="math display">\[
a \; \frac{\partial (E/A)}{\partial \chi} = -b \; \frac{\partial (V_{\mathrm{cmax}}/A)}{\partial \chi}  \;\;\;\;\;\;\;\;\;\;\;\;(1)
\]</span> The optimal <span class="math inline">\(\chi\)</span> solves the above equation and, with <span class="math inline">\(E = 1.6 g_s D\)</span>, <span class="math inline">\(A = g_s (1-\chi)\)</span>, and using the Rubisco-limited assimilation rate: <span class="math display">\[
A = A_C = V_{\mathrm{cmax}} \; \frac{\chi\;c_a-\Gamma^{\ast}}{\chi\;c_a + K}
\]</span> is given by: <span class="math display">\[
\chi = \frac{\Gamma^{\ast}}{c_a} + \left(1- \frac{\Gamma^{\ast}}{c_a}\right)\;\frac{\xi}{\xi + \sqrt{D}}
\]</span> with <span class="math display">\[
\xi = \sqrt{\frac{b(K+\Gamma^{\ast})}{1.6\;a}}
\]</span> The unit cost ratio <span class="math inline">\(b/a\)</span> is also referred to as <span class="math inline">\(\beta\)</span>.</p>
<div id="p-model-run" class="section level2">
<h2>P-model run</h2>
<p>So much for the theory. Let’s run the P-model, without <span class="math inline">\(J_{\text{max}}\)</span> limitation, for one set of inputs, being temperature, PPFD, VPD, CO<span class="math inline">\(_2\)</span>, elevation, and fAPAR.</p>
<p>To do so, run the <code>rpmodel()</code> function from the rsofun package:</p>
<pre class="r"><code>library(rpmodel)
library(dplyr)
# modified seq() function to get a logarithmically spaced sequence
lseq &lt;- function(from=1, to=100000, length.out=6) {
  exp(seq(log(from), log(to), length.out = length.out))
}

## Set parameters
beta &lt;- 146          # unit cost ratio a/b
gamma &lt;- 0.105       # unit cost ratio c/b
kphio &lt;- 0.05        # quantum yield efficiency
c_molmass &lt;- 12.0107 # molar mass, g / mol

## Define environmental conditions
tc &lt;- 20             # temperature, deg C
ppfd &lt;- 300          # mol/m2/d
vpd  &lt;- 1000          # Pa
co2  &lt;- 400          # ppm
elv  &lt;- 0            # m.a.s.l.
fapar &lt;- 1           # fraction

out_analytical &lt;- rsofun::rpmodel(
  tc             = tc,
  vpd            = vpd,
  co2            = co2,
  elv            = elv,
  kphio          = kphio,
  beta           = beta,
  fapar          = fapar,
  ppfd           = ppfd,
  method_optci   = &quot;prentice14&quot;,
  method_jmaxlim = &quot;none&quot;,
  do_ftemp_kphio = FALSE
  )</code></pre>
<p>The function returns a list of variables (see also man page by <code>?rpmodel</code>), including <span class="math inline">\(V_{\mathrm{cmax}}\)</span>, <span class="math inline">\(g_s\)</span>, and all the parameters of the photosynthesis model (<span class="math inline">\(K\)</span>, <span class="math inline">\(\Gamma^{\ast}\)</span>), which are all internally consistent, as can be verified for… <span class="math display">\[
c_i = c_a - A / g_s = \chi c_a
\]</span></p>
<pre class="r"><code>print( out_analytical$ci )</code></pre>
<pre><code>## [1] 28.14209</code></pre>
<pre class="r"><code>print( out_analytical$ca - (out_analytical$gpp / c_molmass) / out_analytical$gs )</code></pre>
<pre><code>## [1] 28.14209</code></pre>
<pre class="r"><code>print( out_analytical$ca * out_analytical$chi )</code></pre>
<pre><code>## [1] 28.14209</code></pre>
<p>Yes.</p>
<p>And for… <span class="math display">\[
A = V_{\text{cmax}} \frac{c_i-\Gamma^{\ast}}{c_i + K} = \phi_0 I_{\text{abs}} \frac{c_i-\Gamma^{\ast}}{c_i + 2 \Gamma^{\ast}} = g_s (c_a - c_i)
\]</span></p>
<pre class="r"><code>print( out_analytical$gpp / c_molmass )</code></pre>
<pre><code>## [1] 10.68456</code></pre>
<pre class="r"><code>print( out_analytical$vcmax * (out_analytical$ci - out_analytical$gammastar) / (out_analytical$ci + out_analytical$kmm ))</code></pre>
<pre><code>## [1] 10.68456</code></pre>
<pre class="r"><code>print( out_analytical$gs * (out_analytical$ca - out_analytical$ci) )</code></pre>
<pre><code>## [1] 10.68456</code></pre>
<pre class="r"><code>print( kphio * ppfd * fapar * (out_analytical$ci - out_analytical$gammastar) / (out_analytical$ci + 2 * out_analytical$gammastar ))</code></pre>
<pre><code>## [1] 10.68456</code></pre>
<p>Yes.</p>
</div>
<div id="numerical-solution" class="section level2">
<h2>Numerical solution</h2>
<p>Instead of formulating the optimality criterium (Eq. 1) with respect to equality in marginal costs (derivative w.r.t. <span class="math inline">\(\chi\)</span>), one may also write this as a minimisation of the combined costs. With <span class="math inline">\(\beta=b/a\)</span>, the following criterium is equivalent to Eq. 1: <span class="math display">\[
E/A + \beta V_{\mathrm{cmax}}/A = min. \;\;\;\;\;\;\;\;(2)
\]</span> This formulation has the advantage that we can easily apply a numerial search algorithm to find the solution in <span class="math inline">\(\chi\)</span>. Why bother? I think it has an advantage as it allows for a more modular treatment, e.g., of transpiration as a function of <span class="math inline">\(g_s\)</span>. But for now, let’s stick with <span class="math inline">\(E=1.6g_sD\)</span>. Eq. 2 can be written out as: <span class="math display">\[
\frac{1.6\;D}{c_a(1-\chi)} + \beta \frac{\chi c_a + K}{\chi c_a - \Gamma^{\ast}} = min.
\]</span></p>
<p>To find the minimum, let’s define the numerical optimization function using the L-BFGS-B algorithm implemented in the <code>optimr</code> package:</p>
<pre class="r"><code>calc_optimal_chi_num &lt;- function( kmm, gammastar, ns_star, ca, vpd, beta ){
  #-----------------------------------------------------------------------
  # Input:    - float, &#39;kmm&#39; : Pa, Michaelis-Menten coeff.
  #           - float, &#39;ns_star&#39;  : (unitless) viscosity correction factor for water
  #           - float, &#39;vpd&#39; : Pa, vapor pressure deficit
  # Output:   float, ratio of ci/ca (chi)
  # Features: Returns an estimate of leaf internal to ambient CO2
  #           partial pressure following the &quot;simple formulation&quot;.
  # Depends:  - kc
  #           - ns
  #           - vpd
  #-----------------------------------------------------------------------
  maximise_this &lt;- function( chi, kmm, gammastar, ns_star, ca, vpd, beta ){
    out &lt;- 1.6 * ns_star * vpd / (ca * (1.0 - chi)) + beta * (chi * ca + kmm)/(chi * ca - gammastar)
    return(out)
  }

  out_optim &lt;- optimr::optimr(
    par       = 0.7,
    lower     = 0.1,
    upper     = 0.99,
    fn        = maximise_this,
    kmm       = kmm,
    gammastar = gammastar,
    ns_star   = ns_star,
    ca        = ca,
    vpd       = vpd,
    beta      = beta,
    method    = &quot;L-BFGS-B&quot;,
    control   = list( maxit = 100, maximize = TRUE )
    )

  return(out_optim$par)
}</code></pre>
<p>Now, let’s find the optimal <span class="math inline">\(\chi\)</span> numerically using above function with the same parameters as calculated inside and returned by the P-model.</p>
<pre class="r"><code>chi_opt &lt;- calc_optimal_chi_num( out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta )
print(chi_opt)</code></pre>
<pre><code>## [1] 0.6943512</code></pre>
<p>As a check: is this the same as returned by the P-model?</p>
<pre class="r"><code>print(out_analytical$chi)</code></pre>
<pre><code>## [1] 0.694352</code></pre>
<p>Practically, yes. A slight difference is due to the limited number of iterations (<code>maxit=100</code>).</p>
<p>Let’s call this <span class="math inline">\(\chi^{\ast}\)</span>. For the P-model, it is then assumed that <span class="math inline">\(A=A_J\)</span> with <span class="math display">\[
A_J = \phi_0 \; I_{\mathrm{abs}}\;\frac{c_a \chi^{\ast} - \Gamma^{\ast}}{c_a \chi^{\ast} + 2\Gamma^{\ast}}
\]</span> It is further assumed that the light-limited and Rubisco-limited assimilation rates are equal for average conditions (which implies that the arguments to the P-model run should represent average conditions). This assumption is also called the “coordination hypothesis.” <span class="math display">\[
A_J = A_C
\]</span> This allows for solving for <span class="math inline">\(V_{\text{cmax}}\)</span>: <span class="math display">\[
V_{\text{cmax}} = \phi_0 \; I_{\mathrm{abs}}\;\frac{c_a \chi^{\ast} + K}{c_a \chi^{\ast} + 2 \Gamma^{\ast} }
\]</span> This is what the P-model returns as can be verified:</p>
<pre class="r"><code>print( out_analytical$vcmax)</code></pre>
<pre><code>## [1] 31.98167</code></pre>
<pre class="r"><code>print( kphio * fapar * ppfd * (out_analytical$ci + out_analytical$kmm) / (out_analytical$ci + 2 * out_analytical$gammastar ) )</code></pre>
<pre><code>## [1] 31.98167</code></pre>
<div id="performance-benchmark" class="section level3">
<h3>Performance benchmark</h3>
<p>TODO: Check computation time for N calls of the numerical <code>calc_optimal_chi_num()</code> vs. the analytical <code>calc_optimal_chi()</code> functions.</p>
</div>
</div>
<div id="optimising-g_s-and-v_textcmax-instead-of-chi" class="section level2">
<h2>Optimising <span class="math inline">\(g_s\)</span> and <span class="math inline">\(V_{\text{cmax}}\)</span> instead of <span class="math inline">\(\chi\)</span></h2>
<p>At the core of the assimilation-transpiration trade-off are the quantities <span class="math inline">\(g_s\)</span> and <span class="math inline">\(V_{\text{cmax}}\)</span>. The combined effect of their magnitudes determines <span class="math inline">\(\chi\)</span>. Why not simutaneously optimize <span class="math inline">\(g_s\)</span> and <span class="math inline">\(V_{\text{cmax}}\)</span>? We can write Eq. 2 also as: <span class="math display">\[
(1.6g_sD + \beta V_{\text{cmax}})/A_C = min. \;\;\;\;\;\;\;(3)
\]</span> and implement this in another numerical search function. Note that <span class="math inline">\(c_i\)</span> can be calculated from solving the equation system <span class="math display">\[
A = V_{\mathrm{cmax}} \; \frac{c_i-\Gamma^{\ast}}{c_i + K} \\
A = g_s(c_a - c_i)
\]</span> which leads to a quadratic equation for <span class="math inline">\(c_i\)</span> where we will only take the positive real part (<code>Re(root_ci)[which(Re(root_ci)&gt;0)]</code>). This can be implemented as follows.</p>
<pre class="r"><code>calc_optimal_gs_vcmax &lt;- function( par, args, maximize=FALSE, return_all=FALSE ){

  kmm       &lt;- args[1]
  gammastar &lt;- args[2]
  ns_star   &lt;- args[3]
  ca        &lt;- args[4]
  vpd       &lt;- args[5]
  beta      &lt;- args[6]

  vcmax &lt;- par[1]
  gs    &lt;- par[2]

  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;- -1.0 * gs
  b_quad &lt;- gs * ca - gs * kmm - vcmax
  c_quad &lt;- gs * ca * kmm + vcmax * gammastar

  root_ci &lt;- try( polyroot( c(c_quad, b_quad, a_quad) ) )

  if (class(root_ci)==&quot;try-error&quot;){

    return( list( vcmax=NA, gs=NA, ci=NA, chi=NA, a_c=NA, cost_transp=NA, cost_vcmax=NA, net_assim=NA  ) )

  } else {

    ## take only real part of the root
    ci &lt;- Re(root_ci)

    ## take only positive root
    ci &lt;- ci[which(ci&gt;0)]   # take positive root

    ## if both are positive, take the one that satisfies ci &lt; ca (don&#39;t know if this is necessary)
    if (length(ci)&gt;1) ci &lt;- ci[which(ci&lt;ca)]

    ## A_c
    a_c &lt;- vcmax * (ci - gammastar) / (ci + kmm)

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    cost_transp &lt;- 1.6 * ns_star * gs * vpd
    cost_vcmax  &lt;- beta * vcmax

    ## Option B: This is equivalent to the P-model with its optimization of ci:ca.
    net_assim &lt;- -(cost_transp + cost_vcmax) / a_c

    if (maximize) net_assim &lt;- -net_assim

    if (return_all){
      return( list( vcmax=vcmax, gs=gs, ci=ci, chi=ci/ca, a_c=a_c, cost_transp=cost_transp, cost_vcmax=cost_vcmax, net_assim=net_assim  ) )
    } else {
      return( net_assim )
    }

  }
}</code></pre>
<p>Now that the target function is defined, we can actually numerically search for the optimal <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>. We need to provide the algorithm with starting values, taken here as the <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span> returned by our initial P-model call.</p>
<pre class="r"><code>wrap_calc_optimal_gs_vcmax &lt;- function( kmm, gammastar, ns_star, ca, vpd, beta, vcmax_start, gs_start ){
  out_optim &lt;- optimr::optimr(
    par        = c( out_analytical$vcmax, out_analytical$gs ), # starting values
    lower      = c( out_analytical$vcmax*0.0001, out_analytical$gs*0.001 ),
    upper      = c( out_analytical$vcmax*20,   out_analytical$gs*30 ),
    fn         = calc_optimal_gs_vcmax,
    args       = c( out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta ),
    method     = &quot;L-BFGS-B&quot;,
    maximize   = TRUE,
    control    = list( maxit = 1000 )
    )
  varlist &lt;- calc_optimal_gs_vcmax( par=out_optim$par, args=c(kmm, gammastar, ns_star, ca, vpd, beta), maximize=FALSE, return_all=TRUE )
  return(varlist)
}</code></pre>
<p>Note that, given that the optimality criterium implemented here (Eq. 3) embodies the same idea and is mathematically identical as Eq. 1, this should yield the same <span class="math inline">\(\chi\)</span> (which can be back-calculated from the optimised <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>). Let’s check if this is the case.</p>
<pre><code>## [1] &quot;Optimal chi from Vcmax-gs optimization: 0.69435201913794&quot;</code></pre>
<pre><code>## [1] &quot;Optimal chi from P-model: 0.694352013202358&quot;</code></pre>
<p>Indeed, this is the same.</p>
<p>Now, we have an optimised <span class="math inline">\(V_{\text{cmax}}\)</span> (lets call it <span class="math inline">\(V_{\text{cmax}}^{\ast}\)</span>), and we can have an optimised <span class="math inline">\(c_i\)</span> which is consistent with the former. Given this, we can take the same step as is done in the P-model and assume that <span class="math inline">\(A_J=A_C\)</span>, which leads to <span class="math display">\[
V_{\text{cmax}} = \phi_0 \; I_{\mathrm{abs}}\;\frac{c_a \chi^{\ast} + K}{c_a \chi^{\ast} + 2 \Gamma^{\ast} }
\]</span> To verify one again:</p>
<pre class="r"><code>print( paste( &quot;optimal Vcmax:&quot;, varlist$vcmax ) )</code></pre>
<pre><code>## [1] &quot;optimal Vcmax: 31.9816667938782&quot;</code></pre>
<pre class="r"><code>print( paste( &quot;Vcmax^P:&quot;, kphio * fapar * ppfd * (varlist$ci + varlist$kmm) / (varlist$ci + 2 * varlist$gammastar )) )</code></pre>
<pre><code>## [1] &quot;Vcmax^P: &quot;</code></pre>
<pre class="r"><code>print( paste(&quot;Vcmax from P-model:&quot;, out_analytical$vcmax ) )</code></pre>
<pre><code>## [1] &quot;Vcmax from P-model: 31.9816667938778&quot;</code></pre>
<p>It’s important to note that calculating <span class="math inline">\(V_{\text{cmax}}\)</span> like this implies the assumption of <span class="math inline">\(A_J = A_C\)</span>, while solving for simultaneously optimal <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span> doesn’t use this assumption. Nevertheless, the results are identical, which may not be immediately obvious.</p>
<div id="light-limitation" class="section level3">
<h3>Light limitation?</h3>
<p>But what about the implicit assumption made in the optmisation that assimilation always follows the Rubisco-limited curve? Shouldn’t there be a limit given by light availability? We can spell this out by calculating <span class="math inline">\(A=min(A_C, A_J)\)</span> or equivalently <span class="math inline">\(c_i=max(c_i^C, c_i^J)\)</span> and modify <code>calc_optimal_gs_vcmax()</code> accordingly. We now need to additionally solve the equation system <span class="math display">\[
A = \phi_0 I_{\text{abs}} \; \frac{c_i-\Gamma^{\ast}}{c_i + 2 \Gamma^{\ast}} \\
A = g_s(c_a - c_i)
\]</span></p>
<p>This is implemented as follows:</p>
<pre class="r"><code>calc_optimal_gs_vcmax_ll &lt;- function( par, args, iabs, kphio, maximize=FALSE, return_all=FALSE ){

  kmm       &lt;- args[1]
  gammastar &lt;- args[2]
  ns_star   &lt;- args[3]
  ca        &lt;- args[4]
  vpd       &lt;- args[5]
  beta      &lt;- args[6]

  vcmax &lt;- par[1]
  gs    &lt;- par[2]

  ## Get ci using Rubisco-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;- -1.0 * gs  # coefficient of quadratic term
  b_quad &lt;- gs * ca - gs * kmm - vcmax
  c_quad &lt;- gs * ca * kmm + vcmax * gammastar

  root_ci_c &lt;- try( polyroot( c(c_quad, b_quad, a_quad) ) )

  ## Get ci using light-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = kphio * iabs * (ci-gammastar)/(ci+2*gammastar)
  ## assim = gs * (ca - ci)
  a_quad &lt;- gs  # coefficient of quadratic term
  b_quad &lt;- kphio * iabs - gs * ca + 2 * gs * gammastar
  c_quad &lt;- - kphio * iabs * gammastar - 2 * gs * ca * gammastar

  root_ci_j &lt;- try( polyroot( c(c_quad, b_quad, a_quad) ) )

  if (class(root_ci_j)==&quot;try-error&quot; || class(root_ci_c)==&quot;try-error&quot;){

    return( list( vcmax=NA, gs=NA, ci=NA, chi=NA, a_c=NA, a_j=NA, ci_c=NA, ci_j=NA, cost_transp=NA, cost_vcmax=NA, net_assim=NA  ) )

  } else {

    ## take only real part of the root
    ci_j &lt;- Re(root_ci_j)
    ci_c &lt;- Re(root_ci_c)

    ## take only positive root
    ci_j &lt;- ci_j[which(ci_j&gt;0)]   # take positive root
    ci_c &lt;- ci_c[which(ci_c&gt;0)]   # take positive root

    ## if both are positive, take the one that satisfies ci &lt; ca (don&#39;t know if this is necessary)
    if (length(ci_j)&gt;1) ci_j &lt;- ci_j[which(ci_j&lt;ca)]
    if (length(ci_c)&gt;1) ci_c &lt;- ci_c[which(ci_c&lt;ca)]

    ## Rubisco-limited
    a_c &lt;- vcmax * (ci_c - gammastar) / (ci_c + kmm)

    ## light-limited
    a_j &lt;- kphio * iabs * (ci_j - gammastar) / (ci_j + 2 * gammastar)

    ## Take minimum of the two assimilation rates
    assim &lt;- min( a_j, a_c )

    # if (return_all){
    #   if (a_j&lt;a_c) print(&quot;Warning: A_J is lower than A_C&quot;)
    # }

    ## ... and consistently the maximum of the two ci
    ci &lt;- max( ci_j, ci_c  )

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    cost_transp &lt;- 1.6 * ns_star * gs * vpd
    cost_vcmax  &lt;- beta * vcmax

    ## Option B: This is equivalent to the P-model with its optimization of ci:ca.
    net_assim &lt;- -(cost_transp + cost_vcmax) / assim

    if (maximize) net_assim &lt;- -net_assim

    if (return_all){
      return( list( vcmax=vcmax, gs=gs, ci=ci, chi=ci/ca, a_c=a_c, a_j=a_j, ci_c=ci_c, ci_j=ci_j, cost_transp=cost_transp, cost_vcmax=cost_vcmax, net_assim=net_assim  ) )
    } else {
      return( net_assim )
    }

  }
}</code></pre>
<p>Let’s compare the results for <span class="math inline">\(\chi\)</span> with this modified version to the original one:</p>
<pre class="r"><code>wrap_calc_optimal_gs_vcmax_ll &lt;- function( ppfd, fapar, kphio, kmm, gammastar, ns_star, ca, vpd, beta, vcmax_start, gs_start ){
  out_optim &lt;- optimr::optimr(
    par        = c( vcmax_start, gs_start ), # starting values
    lower      = c( vcmax_start*0.0001, gs_start*0.001 ),
    upper      = c( vcmax_start*20, gs_start*30 ),
    fn         = calc_optimal_gs_vcmax_ll,
    args       = c(kmm, gammastar, ns_star, ca, vpd, beta),
    iabs       = (ppfd * fapar),
    kphio      = kphio,
    method     = &quot;L-BFGS-B&quot;,
    maximize   = TRUE,
    control    = list( maxit = 1000 )
    )
  varlist &lt;- calc_optimal_gs_vcmax_ll( par=out_optim$par, args=c(kmm, gammastar, ns_star, ca, vpd, beta), iabs=(fapar*ppfd), kphio=kphio, maximize=FALSE, return_all=TRUE )
  return(varlist)
}

varlist_ll &lt;- wrap_calc_optimal_gs_vcmax_ll( ppfd, fapar, kphio, out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta, out_analytical$vcmax, out_analytical$gs )

## Invoke function with optimised Vcmax and gs (in out_optim$par), now returning all variables
print( paste(&quot;Optimal chi from P-model:&quot;, out_analytical$chi ) )</code></pre>
<pre><code>## [1] &quot;Optimal chi from P-model: 0.694352013202358&quot;</code></pre>
<pre class="r"><code>print( paste(&quot;Optimal chi from Vcmax-gs optimization:&quot;, varlist$chi ) )</code></pre>
<pre><code>## [1] &quot;Optimal chi from Vcmax-gs optimization: 0.69435201913794&quot;</code></pre>
<pre class="r"><code>print( paste(&quot;Optimal chi from Vcmax-gs opt. with light limit.:&quot;, varlist_ll$chi ) )</code></pre>
<pre><code>## [1] &quot;Optimal chi from Vcmax-gs opt. with light limit.: 0.694352013202358&quot;</code></pre>
<p>In this case, it’s not a problem. It yields the same <span class="math inline">\(\chi\)</span>. But is this the case across a range of light conditions (remember, that <span class="math inline">\(\chi\)</span> is independent of light in the original model)?</p>
<pre class="r"><code>ppfd_vec &lt;- seq(from=0, to=8000, length.out=50)
out_opt_ll_list &lt;- purrr::map(
  as.list( ppfd_vec),
  ~wrap_calc_optimal_gs_vcmax_ll( ., fapar, kphio, out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta, out_analytical$vcmax, out_analytical$gs )
  )
chi_vec &lt;- out_opt_ll_list %&gt;% purrr::map_dbl(&quot;chi&quot;)
plot( ppfd_vec, chi_vec, type=&quot;l&quot;, xlab=&quot;PPFD&quot;, ylab=&quot;chi&quot;)</code></pre>
<p><img src="theory_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>It is the same. But why?</p>
<!-- Oooops. Our optimal $V_{\text{cmax}}$ is not the same. What does this mean? The P-model assumes that assimilation can be calculated form $c_i$ from the light-limited assimilation rate. The trouble is that if the light-limited one is lower than the Rubisco-limited one, then the optimisation derives a $V_{\text{cmax}}$ at which it cannot operate. The $V_{\text{cmax}}$ derived from optimised $\chi$ (and hence $c_i$) is not what was "paid for" in the optmisation. -->
</div>
</div>
<div id="the-same-with-a-twist" class="section level2">
<h2>The same with a twist</h2>
<p>Arguably the most intuitive way to specify an optimality criterium that (seemingly) embodies the same idea like Eqs. 1 and 3, is to maximise a “net assimilation” rate, defined as assimilation <em>minus</em> the costs for maintaining the transpiration stream and carboxylation capacity, instead of the costs per unit assimilation as done above. We can write this as follows:</p>
<p>Maximise the following term numerically, again subject to <span class="math inline">\(V_{\mathrm{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>: <span class="math display">\[
A_n = A - aE -bV_{\text{cmax}} = max. \;\;\;\;\;\;\;\;\;\;\;\;(4)
\]</span> We can divide this by <span class="math inline">\(a\)</span> in order to define it with the cost ratio <span class="math inline">\(\beta\)</span> which we have used above. However, an absolute cost remains in the first term: <span class="math display">\[
A_n = \frac{1}{a} A - E -\beta V_{\text{cmax}} = max. \;\;\;\;\;\;\;\;\;\;\;\;(5)
\]</span> So be it. But this has implications because we now need to know the abosulte cost terms and not just their ratio. Anyways, we can implement Eq. 5 analogously to above, now with an additional argument <code>cost_scalar</code>.</p>
<pre class="r"><code>calc_net_assim_eq4 &lt;- function( par, args, iabs, kphio, cost_scalar, maximize=FALSE, return_all=FALSE ){

  kmm       &lt;- args[1]
  gammastar &lt;- args[2]
  ns_star   &lt;- args[3]
  ca        &lt;- args[4]
  vpd       &lt;- args[5]
  beta      &lt;- args[6]

  vcmax &lt;- par[1]
  gs    &lt;- par[2]

  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;- -1.0 * gs
  b_quad &lt;- gs * ca - gs * kmm - vcmax
  c_quad &lt;- gs * ca * kmm + vcmax * gammastar

  root_ci &lt;- try( polyroot( c(c_quad, b_quad, a_quad) ) )

  if (class(root_ci)==&quot;try-error&quot;){

    return( list( vcmax=NA, gs=NA, ci=NA, chi=NA, a_c=NA, cost_transp=NA, cost_vcmax=NA, net_assim=NA ) )

  } else {

    ## take only real part of the root
    ci &lt;- Re(root_ci)

    ## take only positive root
    ci &lt;- ci[which(ci&gt;0)]   # take positive root

    ## if both are positive, take the one that satisfies ci &lt; ca (don&#39;t know if this is necessary)
    if (length(ci)&gt;1) ci &lt;- ci[which(ci&lt;ca)]

    ## A_c
    a_c &lt;- vcmax * (ci - gammastar) / (ci + kmm)

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    ## here cost_scalar basically corresponds to a in Eq. 2
    cost_transp &lt;- cost_scalar * 1.6 * ns_star * gs * vpd
    cost_vcmax  &lt;- cost_scalar * beta * vcmax

    ## The trouble is that A_c is used to determine optimality here, but actual assimilation is
    ## later calculated following the light-limited function for A_j.
    net_assim &lt;- a_c - cost_transp - cost_vcmax

    if (maximize) net_assim &lt;- -net_assim

    if (return_all){
      return( list( vcmax=vcmax, gs=gs, ci=ci, chi=ci/ca, a_c=a_c, cost_transp=cost_transp, cost_vcmax=cost_vcmax, net_assim=net_assim  ) )
    } else {
      return( net_assim )
    }
  }
}</code></pre>
<p>We don’t know <code>cost_scalar</code>, so let’s just pick a random one (0.0003 used here) and hope we get the same result for <span class="math inline">\(\chi\)</span> as above.</p>
<pre><code>## [1] &quot;optimal Vcmax: 639.633335877556&quot;</code></pre>
<pre><code>## [1] &quot;optimal gs: 25.874954924183&quot;</code></pre>
<pre><code>## [1] &quot;Optimal chi from Vcmax-gs optimization (Eq. 5): 0.778413519903281&quot;</code></pre>
<pre><code>## [1] &quot;Optimal chi from P-model: 0.694352013202358&quot;</code></pre>
<p>Ooops. Not the same.</p>
<p>The problem of all of this is that the cost factor that scales both the cost of <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span> equally is missing from the optimization criterium when <span class="math inline">\(E/A + \beta V_{\text{cmax}}/A = max.\)</span> is used. Let’s try to find a value for the cost scalar so that we get the same <span class="math inline">\(\chi\)</span> as when following Eq. 2 or 3 for the opmitisation.</p>
<pre class="r"><code>setzero &lt;- function( x_cost, chi_target, out_analytical, fapar, ppfd, vpd ){

  args &lt;- c( out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta )

  out_optim &lt;- optimr::optimr(
    par        = c( out_analytical$vcmax, out_analytical$gs ),
    lower      = c( out_analytical$vcmax*0.0001, out_analytical$gs*0.001 ),
    upper      = c( out_analytical$vcmax*20,   out_analytical$gs*30 ),
    fn         = calc_net_assim_eq4,
    args       = args,
    iabs       = (fapar * ppfd),
    kphio      = kphio,
    cost_scalar = x_cost,
    maximize   = TRUE,
    method     = &quot;L-BFGS-B&quot;,
    control    = list( maxit = 1000 )
    )

  list_numerical &lt;- calc_net_assim_eq4( out_optim$par, args, iabs=(fapar * ppfd), kphio = kphio, cost_scalar=x_cost, return_all = TRUE )

  out &lt;- chi_target - list_numerical$chi

  return(abs(out))
}

sapply( lseq( from=0.0001, to=0.005, length.out = 100), FUN =  function(x) setzero( x, out_analytical$chi, out_analytical, fapar, ppfd, vpd ) ) %&gt;%
plot( lseq( from=0.0001, to=0.005, length.out = 100), ., type=&quot;l&quot; )
abline(h=0, lty=2)

## Watch out: numerical noise is happening. For this example, chose starting point where visually determined in plot above
unitcost_root &lt;- optimr::optimr(
  par            = 0.002,
  fn             = setzero,
  chi_target     = out_analytical$chi,
  out_analytical = out_analytical,
  fapar          = fapar,
  ppfd           = ppfd,
  vpd            = vpd,
  control        = list( maxit = 100000 )
  )
abline( v = unitcost_root$par, col=&quot;red&quot; )</code></pre>
<p><img src="theory_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>Hence, the cost scalar for which the result for <span class="math inline">\(\chi\)</span> is is identical to the P-model’s solution, is:</p>
<pre class="r"><code>print( unitcost_root$par )</code></pre>
<pre><code>## [1] 0.001717135</code></pre>
<p>Let’s verify this as above, setting <code>cost_scalar = unitcost_root$par</code>:</p>
<pre><code>## [1] &quot;Optimal chi from absolute-cost-Vcmax-gs optimization (Eq. 5): 0.694352013202358&quot;</code></pre>
<pre><code>## [1] &quot;Optimal chi from P-model: 0.694352013202358&quot;</code></pre>
<p>Ok, they are now identical.</p>
<p>Some illustration of this: Plot a surface of <span class="math inline">\(A_n\)</span> as a function of <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>, with a red point where the numerical optimization found the maximum, and a green point, where the analytical solution lies.</p>
<pre class="r"><code>len_vcmax &lt;- 50
len_gs &lt;- 50
vcmax_vec &lt;- lseq(out_analytical$vcmax*0.0001, out_analytical$vcmax*5, length.out = len_vcmax)
gs_vec &lt;- lseq(out_analytical$gs*0.001, out_analytical$gs*5, length.out = len_gs)
args &lt;- c( out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta )

A_net &lt;- expand.grid(vcmax_vec, gs_vec) %&gt;%
  setNames( c(&quot;vcmax&quot;, &quot;gs&quot;) ) %&gt;%
  rowwise() %&gt;%
  do( net_assim = calc_net_assim_eq4(
    c(.$vcmax, .$gs),
    args=args,
    iabs=(fapar * ppfd),
    kphio = kphio,
    cost_scalar=unitcost_root$par,
    maximize=FALSE
    ) ) %&gt;%
  tidyr::unnest(net_assim) %&gt;%
  as.matrix() %&gt;%
  array( dim=c(len_vcmax,len_gs) )

pmat &lt;- persp( (vcmax_vec), (gs_vec), A_net,
               phi = 10, # Azimut, 0 is along gs_vec axis
               theta = 30,
               col=&quot;lightblue&quot;
               )
points( trans3d( (out_optim$par[1]), (out_optim$par[2]), -out_optim$value, pmat ), pch=16, col=&quot;red&quot;, cex=1.8 )

# Add point for analytically-determined Vcmax and gs, and the net assimilation rate with the same unit cost as above:
cost_transp &lt;- unitcost_root$par * 1.6 * out_analytical$ns_star * out_analytical$gs * vpd
cost_vcmax &lt;- beta * unitcost_root$par * out_analytical$vcmax
net_assim_analytical &lt;- out_analytical$gpp / c_molmass - cost_transp - cost_vcmax
points( trans3d( (out_analytical$vcmax), (out_analytical$gs), net_assim_analytical, pmat ), pch=16, col=&quot;green&quot;, cex=1 )</code></pre>
<p><img src="theory_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<pre class="r"><code># numerical (of course, the value is not the same as analytical, because it&#39;s the optimization target and not A_j. Re-calculate A_j from optimized Vcmax and gs.):
print( c(out_optim$par[1], out_optim$par[2], -out_optim$value) )</code></pre>
<pre><code>## [1]  3.198167e+01  8.624985e-01 -5.199398e-06</code></pre>
<pre class="r"><code>out_optim_numerical &lt;- calc_net_assim_eq4(
  par            = c(out_optim$par[1], out_optim$par[2]),
  args           = c( out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta ),
  iabs           = (fapar * ppfd),
  kphio          =  kphio,
  cost_scalar    = unitcost_root$par,
  return_all     = TRUE
  )
print( c( out_optim_numerical$vcmax, out_optim_numerical$gs, out_optim_numerical$net_assim ))</code></pre>
<pre><code>## [1]  3.198167e+01  8.624985e-01 -5.199398e-06</code></pre>
<pre class="r"><code>print( c(out_analytical$vcmax, out_analytical$gs, net_assim_analytical) )</code></pre>
<pre><code>## [1]  3.198167e+01  8.624985e-01 -5.199398e-06</code></pre>
<p>And in 2D. For fixed (optimal) <span class="math inline">\(g_s\)</span>.</p>
<pre class="r"><code>## cost_scalar is searched by hand
sapply( as.list(vcmax_vec), FUN = function(x) calc_net_assim_eq4( c(x, out_optim$par[2]), args, iabs=(fapar * ppfd), kphio = kphio, cost_scalar = unitcost_root$par ) ) %&gt;%
  plot( vcmax_vec, ., type=&quot;l&quot;, xlab=&quot;Vcmax&quot;, ylab=&quot;net A&quot; )
abline(v=out_optim$par[1], lty=3)
points( (out_optim$par[1]), -out_optim$value, pch=16, col=&quot;red&quot;, cex=1.8 )
points( (out_analytical$vcmax), net_assim_analytical, pch=16, col=&quot;green&quot;, cex=1 )</code></pre>
<p><img src="theory_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>And for fixed (optimal) <span class="math inline">\(V_{\text{cmax}}\)</span>:</p>
<pre class="r"><code>## cost_scalar is searched by hand
sapply( as.list(gs_vec), FUN = function(x) calc_net_assim_eq4( c(out_optim$par[1], x), args, iabs=(fapar * ppfd), kphio = kphio, cost_scalar = unitcost_root$par ) ) %&gt;% plot( gs_vec, ., type=&quot;l&quot;, xlab=&quot;gs&quot;, ylab=&quot;net A&quot; )
abline( v=out_optim$par[2], lty=3 )
points( (out_optim$par[2]), -out_optim$value, pch=16, col=&quot;red&quot;, cex=1.8 )
points( (out_analytical$gs), net_assim_analytical, pch=16, col=&quot;green&quot;, cex=1 )</code></pre>
<p><img src="theory_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<!-- The reason why the red and green dots are not exactly on top of each other is because the optimisation (red) returns $A_{n}=A_c - \psi_{\text{transp}} - \psi_{\text{Vcmax}}$, while the analytical (green point) returns $A_n = A_j - \psi_{\text{transp}} - \psi_{\text{Vcmax}}$. -->
</div>
<div id="optimality-for-the-diurnal-cycle" class="section level2">
<h2>Optimality for the diurnal cycle</h2>
<p>Variability in ambient conditions is small between days (within a limited period, typically weeks-months), compared to conditions within days. Non-linearity in <span class="math inline">\(A_J\)</span> and <span class="math inline">\(A_C\)</span>, and <span class="math inline">\(\chi\)</span> as a function of <span class="math inline">\(D\)</span> suggests that using average daytime conditions is not a valid simplification for optimality in <span class="math inline">\(\chi\)</span> for an entire diurnal cycle (assuming that <span class="math inline">\(\chi\)</span>, and hence <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>, don’t vary throughout a day).</p>
<p>What we’re actually after is: <span class="math display">\[
\sum_t  (A_t - a E_t - bV_{\text{cmax}, t}) = max. \;\;\;\;\;\;\;\;(6)
\]</span> This can also be expressed as: <span class="math display">\[
a \frac{\sum E_t}{\sum A_t} + b \frac{\sum V_{\text{cmax}, t}}{\sum A_t} = min. \;\;\;\;\;\;\;\;(7)
\]</span> A minimum is given when the derivative of this expression w.r.t. <span class="math inline">\(\chi\)</span> is zero: <span class="math display">\[
a \frac{\partial \frac{\sum E}{\sum A}}{\partial \chi} + b \frac{\partial \frac{\sum V_{\text{cmax}}}{\sum A}}{\partial \chi} = 0  \;\;\;\;\;\;\;\;(8)
\]</span> The trouble is that <span class="math display">\[
\frac{\sum E}{\sum A} \ne \sum E/A
\]</span> and hence this Eq. 8 cannot be solved analytically (or can it?). Instead, one could solve Eq. 7 numerically.</p>
</div>
<div id="introducing-j_textmax-limitation" class="section level2">
<h2>Introducing <span class="math inline">\(J_{\text{max}}\)</span> limitation</h2>
<p>From Eq. 4 it’s straight-forward to introduce the cost of maintaining a certain <span class="math inline">\(J_{\text{max}}\)</span> in the optimality criterium as <span class="math display">\[
A_n = A - aE -bV_{\text{cmax}} - cJ_{\text{max}} = max. \;\;\;\;\;\;\;\;\;\;\;\;(5)
\]</span></p>
<p>In the optimisation routine it is now essential to take <span class="math inline">\(A = min(A_C, A_J)\)</span>. With <span class="math inline">\(J_{\text{max}}\)</span> limitation factored in using the Smith (1937) formulation, <span class="math inline">\(A_J\)</span> is <span class="math display">\[
A_J = \phi_0 \; I_{\mathrm{abs}} \; \frac{c_i - \Gamma^{\ast}}{c_i + 2\Gamma^{\ast}} \; \frac{1}{\sqrt{1+ \left( \frac{4\;\phi_0\;I_{\mathrm{abs}}}{J_{\mathrm{max}}} \right)^{2}}}
\]</span></p>
<p>We can implement this as follows::</p>
<pre class="r"><code>calc_optimal_gs_vcmax_jmax &lt;- function( par, args, iabs, kphio, cost_scalar, maximize=FALSE, return_all=FALSE ){

  kmm       &lt;- args[1]
  gammastar &lt;- args[2]
  ns_star   &lt;- args[3]
  ca        &lt;- args[4]
  vpd       &lt;- args[5]
  beta      &lt;- args[6]
  gamma &lt;- args[7]

  vcmax &lt;- par[1]
  gs    &lt;- par[2]
  jmax  &lt;- par[3]

  calc_L_factor &lt;- function( jmax, iabs, kphio ){
    1.0 / sqrt( 1 + (4 * kphio * iabs / jmax )^2 )
  }

  ## Get ci using Rubisco-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;- -1.0 * gs  # coefficient of quadratic term
  b_quad &lt;- gs * ca - gs * kmm - vcmax
  c_quad &lt;- gs * ca * kmm + vcmax * gammastar

  root_ci_c &lt;- try( polyroot( c(c_quad, b_quad, a_quad) ) )

  ## Get ci using light-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = kphio * iabs * (ci-gammastar)/(ci+2*gammastar)
  ## assim = gs * (ca - ci)
  L_factor &lt;- calc_L_factor( jmax, iabs, kphio )
  a_quad &lt;- L_factor * gs  # coefficient of quadratic term
  b_quad &lt;- kphio * iabs - L_factor * gs * ca + 2 * L_factor * gs * gammastar
  c_quad &lt;- - kphio * iabs * gammastar - 2 * L_factor * gs * ca * gammastar    # minus was missing!!!

  root_ci_j &lt;- try( polyroot( c(c_quad, b_quad, a_quad) ) )

  if (class(root_ci_j)==&quot;try-error&quot; || class(root_ci_c)==&quot;try-error&quot;){

    if (!return_all){
      return(9999.9)
    } else {
      return( list( vcmax=NA, gs=NA, ci=NA, chi=NA, a_c=NA, a_j=NA, ci_c=NA, ci_j=NA, cost_transp=NA, cost_vcmax=NA, cost_jmax=NA, net_assim=NA ) )
    }

  } else {

    ## take only real part of the root
    ci_j &lt;- Re(root_ci_j)
    ci_c &lt;- Re(root_ci_c)

    ## take only positive root
    ci_j &lt;- ci_j[which(ci_j&gt;0)]   # take positive root
    ci_c &lt;- ci_c[which(ci_c&gt;0)]   # take positive root

    ## if both are positive, take the one that satisfies ci &lt; ca (don&#39;t know if this is necessary)
    if (length(ci_j)&gt;1) ci_j &lt;- ci_j[which(ci_j&lt;ca)]
    if (length(ci_c)&gt;1) ci_c &lt;- ci_c[which(ci_c&lt;ca)]

    ## Rubisco-limited
    a_c &lt;- vcmax * (ci_c - gammastar) / (ci_c + kmm)

    ## light-limited
    a_j &lt;- kphio * iabs * (ci_j - gammastar) / (ci_j + 2 * gammastar)

    ## Take minimum of the two assimilation rates
    assim &lt;- min( a_j, a_c )

    # if (return_all){
    #   if (a_j&lt;a_c) print(&quot;Warning: A_J is lower than A_C&quot;)
    # }

    ## ... and consistently the maximum of the two ci
    ci &lt;- max( ci_j, ci_c  )

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    ## here cost_scalar basically corresponds to a in Eq. 2
    cost_transp &lt;- cost_scalar * 1.6 * ns_star * gs * vpd
    cost_vcmax  &lt;- cost_scalar * beta * vcmax
    cost_jmax   &lt;- gamma * jmax    # Tried here without cost_scalar because we know that dA/dJmax = 0.105 = gamma

    ## The trouble is that A_c is used to determine optimality here, but actual assimilation is
    ## later calculated following the light-limited function for A_j.
    net_assim &lt;- assim - cost_transp - cost_vcmax - cost_jmax

    if (maximize) net_assim &lt;- -net_assim

    if (return_all){
      return( list( vcmax=vcmax, gs=gs, ci=ci, chi=ci/ca, a_c=a_c, a_j=a_j, ci_c=ci_c, ci_j=ci_j, cost_transp=cost_transp, cost_vcmax=cost_vcmax, cost_jmax=cost_jmax, net_assim=net_assim  ) )
    } else {
      return( net_assim )
    }

  }
}</code></pre>
<p>Let’s compare the results for <span class="math inline">\(\chi\)</span> with <span class="math inline">\(J_{\text{max}}\)</span> limitation and without.</p>
<pre class="r"><code>## test
test &lt;- calc_optimal_gs_vcmax_jmax(
  par = c( out_analytical$vcmax, out_analytical$gs, out_analytical$vcmax ),
  args = c( out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta, gamma),
  iabs = (ppfd * fapar),
  kphio = kphio,
  cost_scalar = unitcost_root$par,
  maximize=FALSE,
  return_all=TRUE
  )

wrap_calc_optimal_gs_vcmax_jmax &lt;- function( ppfd, fapar, kphio, kmm, gammastar, ns_star, ca, vpd, beta, gamma, cost_scalar, vcmax_start, gs_start, jmax_start ){
  out_optim &lt;- optimr::optimr(
    par        = c( vcmax_start, gs_start, jmax_start ), # starting values
    lower      = c( vcmax_start*0.0001, gs_start*0.001, jmax_start*0.001 ),
    upper      = c( vcmax_start*20, gs_start*30, jmax_start*30 ),
    fn         = calc_optimal_gs_vcmax_jmax,
    args       = c(kmm, gammastar, ns_star, ca, vpd, beta, gamma),
    iabs       = (ppfd * fapar),
    kphio      = kphio,
    cost_scalar = cost_scalar,
    method     = &quot;L-BFGS-B&quot;,
    maximize   = TRUE,
    control    = list( maxit = 1000 )
    )
  varlist &lt;- calc_optimal_gs_vcmax_jmax( par=out_optim$par, args=c(kmm, gammastar, ns_star, ca, vpd, beta, gamma), iabs=(fapar*ppfd), kphio=kphio, cost_scalar=cost_scalar, maximize=FALSE, return_all=TRUE )
  return(varlist)
}

varlist_jmax &lt;- wrap_calc_optimal_gs_vcmax_jmax( ppfd, fapar, kphio, out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta, gamma, unitcost_root$par, out_analytical$vcmax, out_analytical$gs, out_analytical$vcmax )

## Invoke function with optimised Vcmax and gs (in out_optim$par), now returning all variables
print( paste(&quot;Optimal chi from P-model:&quot;, out_analytical$chi ) )</code></pre>
<pre><code>## [1] &quot;Optimal chi from P-model: 0.694352013202358&quot;</code></pre>
<pre class="r"><code>print( paste(&quot;Optimal chi from Vcmax-gs optimization:&quot;, varlist$chi ) )</code></pre>
<pre><code>## [1] &quot;Optimal chi from Vcmax-gs optimization: 0.694352013202358&quot;</code></pre>
<pre class="r"><code>print( paste(&quot;Optimal chi from Vcmax-gs opt. with light limit.:&quot;, varlist_ll$chi ) )</code></pre>
<pre><code>## [1] &quot;Optimal chi from Vcmax-gs opt. with light limit.: 0.694352013202358&quot;</code></pre>
<pre class="r"><code>print( paste(&quot;Optimal chi from Vcmax-gs opt. with Jmax limit.:&quot;, varlist_jmax$chi ) )</code></pre>
<pre><code>## [1] &quot;Optimal chi from Vcmax-gs opt. with Jmax limit.: 0.96167641552231&quot;</code></pre>
<p>For a set of light levels</p>
<pre class="r"><code>ppfd_vec &lt;- seq(from=0, to=8000, length.out=50)
out_opt_ll_list &lt;- purrr::map(
  as.list( ppfd_vec),
  ~wrap_calc_optimal_gs_vcmax_ll( ., fapar, kphio, out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta, out_analytical$vcmax, out_analytical$gs )
  )
chi_vec_ll &lt;- out_opt_ll_list %&gt;% purrr::map_dbl(&quot;chi&quot;)

out_opt_jmax_list &lt;- purrr::map(
  as.list( ppfd_vec),
  ~wrap_calc_optimal_gs_vcmax_jmax( ., fapar, kphio, out_analytical$kmm, out_analytical$gammastar, out_analytical$ns_star, out_analytical$ca, vpd, beta, gamma, unitcost_root$par, out_analytical$vcmax, out_analytical$gs, out_analytical$vcmax )
  )
chi_vec_jmax &lt;- out_opt_jmax_list %&gt;% purrr::map_dbl(&quot;chi&quot;)

plot( ppfd_vec, chi_vec_ll, type=&quot;l&quot;, xlab=&quot;PPFD&quot;, ylab=&quot;chi&quot;, ylim=c(0,1))
lines( ppfd_vec, chi_vec_jmax, col=&quot;blue&quot; )</code></pre>
<p><img src="theory_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
